<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
  <script>
    /* 
      由小到大:
      Atom 原子
      Expression 表达式
      Statement 状态
      Structure 结构
      Program/Module 模块


      Grammer:
      Tree vs Priority
      运算符: + - * / () 运算优先级


      构建语法树: AST
      中缀树

      Member 成员运算符 : a.b a[b] foo`string` super.b super[`b`] new.target new Foo()
      运行时字符串变量

      foo`string` 前面函数名,传入函数当作参数

      super关键字,构造函数

      new.target new Foo() 

      new Expression 表达式  eg  new a()()    new new a()


      运行时设施:  Object Key     delete assign
      Reference 标准中的类型,而不是语言中的类型
      key可以是string,Symbol


      函数调用Expression
      Call:  foo()  super()  foo()['b']  foo().b  foo()`abc`
      后面的.运算降低了它的优先级
      语法结构会造成不同的优先级,比如圆括号,产生式更加严谨

      eg. new a()[`b`] 前后结构顺序,跟谁结合的问题


      Left Handside & Right Handside
      a.b = c; 
      a + b = c; 错误 a+b 是Right Handside
      只有Left Handside Expression 才能放在等号左边

      update自增自减:  a++ a-- --a ++a   ++a++ ++(a++)    优先会跟后面结合,不合法的

      Unary单目运算符:  delete a.b  void foo()  typeof a  +a  -a  ~a  !a  await a

      js中唯一一个: 右结合运算符: a ** b ** c  先计算 b ** 


      乘除: * / %

      加减: + - (+ 数字,字符串拼接两种)

      Shift位运算: << >> >>>带符号

      关系比较: < > <= >= instanceof 

      字符串比较(字典顺序): in 

      Equality == != === !==

      类型相等正常比较; 类型不同 string == boolean 会把boolean优先转换为Number(隐式比较,通过Number)

      位运算: & ^ |

      逻辑运算符(短路原则): && || 

      Conditional三目运算符(也有短路原则) ?:
     */


  </script>
</body>
</html>